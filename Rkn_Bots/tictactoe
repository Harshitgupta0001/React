from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
import random, asyncio

# In-memory game storage
games = {}

# Generate game board
def generate_board(board, game_id, include_quit=True):
    buttons = []
    for i in range(3):
        row = []
        for j in range(3):
            index = i * 3 + j
            cell = board[index]
            display = {"X": "❌", "O": "⭕", " ": "➖"}[cell]
            if cell == " ":
                row.append(InlineKeyboardButton(display, callback_data=f"move|{game_id}|{index}"))
            else:
                row.append(InlineKeyboardButton(display, callback_data="ignore"))
        buttons.append(row)

    if include_quit:
        buttons.append([InlineKeyboardButton("❌ Quit", callback_data=f"quit|{game_id}")])

    return InlineKeyboardMarkup(buttons)

# Check winner or tie
def check_winner(board):
    combos = [(0,1,2), (3,4,5), (6,7,8), (0,3,6), (1,4,7), (2,5,8), (0,4,8), (2,4,6)]
    for x, y, z in combos:
        if board[x] == board[y] == board[z] and board[x] != " ":
            return board[x]
    if " " not in board:
        return "tie"
    return None

# Timeout logic
async def start_timeout(client, game_id, timeout=60):
    await asyncio.sleep(timeout)
    game = games.get(game_id)
    if game and not game.get("winner") and game.get("status") == "playing":
        turn = game["turn"]
        opponent_id = game["player_o"] if turn == game["player_x"] else game["player_x"]
        try:
            opponent = await client.get_users(opponent_id)
            msg = f"**Timeout!** <a href='tg://user?id={turn}'>Player</a> took too long.\n**Winner:** {opponent.mention}"
        except:
            msg = "**Timeout!** Player took too long.\nOpponent wins!"
        await game["message"].edit_text(msg)
        games.pop(game_id, None)

# Bot move
def best_move(board):
    best_score = -float("inf")
    move = None
    for i in range(9):
        if board[i] == " ":
            board[i] = "O"
            score = minimax(board, 0, False)
            board[i] = " "
            if score > best_score:
                best_score = score
                move = i
    return move

def minimax(board, depth, is_maximizing):
    winner = check_winner(board)
    if winner == "O":
        return 1
    elif winner == "X":
        return -1
    elif " " not in board:
        return 0

    if is_maximizing:
        best_score = -float("inf")
        for i in range(9):
            if board[i] == " ":
                board[i] = "O"
                score = minimax(board, depth + 1, False)
                board[i] = " "
                best_score = max(score, best_score)
        return best_score
    else:
        best_score = float("inf")
        for i in range(9):
            if board[i] == " ":
                board[i] = "X"
                score = minimax(board, depth + 1, True)
                board[i] = " "
                best_score = min(score, best_score)
        return best_score

# Start game
@Client.on_message(filters.command("tictactoe"))
async def start_game(client, message: Message):
    user1 = message.from_user.id
    chat_id = message.chat.id
    board = [" "] * 9
    game_id = message.id

    if message.chat.type == "private" or len(message.command) == 1:
        games[game_id] = {
            "chat_id": chat_id, "player_x": user1, "player_o": 0,
            "turn": user1, "vs_bot": True, "board": board,
            "status": "playing"
        }
        sent = await message.reply(
            f"**You vs Bot**\n**Turn:** {message.from_user.mention}",
            reply_markup=generate_board(board, game_id)
        )
        games[game_id]["message"] = sent
        asyncio.create_task(start_timeout(client, game_id))

    elif len(message.command) == 2:
        try:
            opponent = await client.get_users(message.command[1])
            user2 = opponent.id
            if user1 == user2:
                return await message.reply("You can't play with yourself.")
            
            games[game_id] = {
                "chat_id": chat_id,
                "player_x": user1,
                "player_o": user2,
                "status": "pending"
            }
            await message.reply(
                f"{message.from_user.mention} challenged {opponent.mention} to a game of Tic Tac Toe!",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("✅ Accept", callback_data=f"accept|{game_id}"),
                    InlineKeyboardButton("❌ Decline", callback_data=f"decline|{game_id}")
                ]])
            )
        except Exception:
            await message.reply("Invalid username or user not found.")
    else:
        await message.reply("Usage: `/tictactoe` or `/tictactoe @username`", quote=True)

# Accept or Decline Challenge
@Client.on_callback_query(filters.regex("^accept|decline"))
async def handle_challenge_response(client, cb: CallbackQuery):
    action, game_id = cb.data.split("|")
    game_id = int(game_id)
    user_id = cb.from_user.id

    game = games.get(game_id)
    if not game or game.get("status") != "pending":
        return await cb.answer("Game not found or already started.", show_alert=True)

    if user_id != game["player_o"]:
        return await cb.answer("Only the challenged player can respond.", show_alert=True)

    if action == "decline":
        await cb.message.edit_text(f"{cb.from_user.mention} declined the game request.")
        games.pop(game_id, None)
        return

    # Accept the challenge
    board = [" "] * 9
    game.update({
        "board": board,
        "turn": game["player_x"],
        "vs_bot": False,
        "status": "playing"
    })

    sent = await cb.message.reply(
        f"{(await client.get_users(game['player_x'])).mention} vs {cb.from_user.mention}\n**Turn:** {(await client.get_users(game['player_x'])).mention}",
        reply_markup=generate_board(board, game_id)
    )
    game["message"] = sent
    await cb.message.delete()
    asyncio.create_task(start_timeout(client, game_id))

# Handle Moves
@Client.on_callback_query(filters.regex("^move"))
async def handle_move(client, cb: CallbackQuery):
    _, game_id, index = cb.data.split("|")
    game_id = int(game_id)
    index = int(index)
    user_id = cb.from_user.id

    game = games.get(game_id)
    if not game or game.get("status") != "playing":
        return await cb.answer("Game not found or expired.", show_alert=True)

    board = game["board"]
    turn = game["turn"]
    player_x = game["player_x"]
    player_o = game["player_o"]
    is_bot = game["vs_bot"]

    if turn != user_id:
        return await cb.answer("Not your turn!", show_alert=True)

    if board[index] != " ":
        return await cb.answer("Already taken!", show_alert=True)

    mark = "X" if user_id == player_x else "O"
    board[index] = mark

    winner = check_winner(board)
    if winner:
        game["winner"] = True
        if winner == "tie":
            text = "**Match Draw!**"
        elif is_bot and winner == "O":
            text = "**Bot wins!**"
        else:
            text = f"**Winner:** {cb.from_user.mention}"
        await cb.message.edit_text(text)
        games.pop(game_id, None)
        return

    if is_bot:
        game["turn"] = 0
        bot_move = best_move(board)
        board[bot_move] = "O"
        winner = check_winner(board)
        if winner:
            text = "**Match Draw!**" if winner == "tie" else "**Bot wins!**"
            await cb.message.edit_text(text)
            games.pop(game_id, None)
            return
        game["turn"] = player_x
    else:
        game["turn"] = player_o if turn == player_x else player_x

    turn_user = "Bot" if is_bot and game["turn"] == 0 else (await client.get_users(game["turn"])).mention
    await cb.message.edit_text(
        f"**Turn:** {turn_user}",
        reply_markup=generate_board(board, game_id)
    )
    asyncio.create_task(start_timeout(client, game_id))

# Quit Game
@Client.on_callback_query(filters.regex("^quit"))
async def quit_game(client, cb: CallbackQuery):
    _, game_id = cb.data.split("|")
    game_id = int(game_id)
    user_id = cb.from_user.id

    game = games.get(game_id)
    if not game:
        return await cb.answer("Game not found or expired.", show_alert=True)

    player_x = game["player_x"]
    player_o = game["player_o"]

    if user_id != player_x and user_id != player_o:
        return await cb.answer("You're not part of this game.", show_alert=True)

    opponent_id = player_o if user_id == player_x else player_x
    try:
        opponent = await client.get_users(opponent_id)
        text = f"**{cb.from_user.mention} quit the game!**\n**Winner:** {opponent.mention}"
    except:
        text = f"**{cb.from_user.mention} quit the game!**\nOpponent wins!"

    await cb.message.edit_text(text)
    games.pop(game_id, None)

# Ignore Button
@Client.on_callback_query(filters.regex("^ignore"))
async def ignore(cb: CallbackQuery):
    await cb.answer()
